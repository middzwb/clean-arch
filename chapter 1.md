# 什么设计和架构
---

这些年来有很多关于设计和架构的迷惑。什么是设计？什么是架构？两者区别是什么？

本书的目标之一就是打破所有的迷惑，一劳永逸（？）的定义什么是设计和架构。首先，我将断言这两者之间没有任何不同，一点也不

“架构”这个词经常被用在脱离底层细节的高层上下文中。尽管“设计”看起来更像是在表达底层的结构和决策（？），但当你考虑一个真正的设计师（架构师？）在做什么的时候，这个用法是荒谬的。

考虑设计我家的设计师，我家有架构吗，当然有。是什么呢？是房子的形状，外观，高度，以及空间和屋子的布局。但当我看设计师设计的图稿时，我看到了很多的底层细节，我看到了每一个出口，开关和灯放在那里，我看大了每个开关控制哪个灯，我看到了炉子在哪里放置，热水器和水泵的大小和位置。我看到了墙，屋顶和地基构建的细节。

简断截说，我看到了支持者高级决策的所有小细节。我也看到了这些底层细节和高层决策都是我房子设计的一部分。

软件设计也是如此,底层细节和高层结构都是设计的一部分。他们组成了一个连续的定义了系统形状的结构。两者缺一不可；实际上，两者之间没有明确的分界线。这里有一些简单的从最高层到最底层的连续的决策。

## 目标？

这些决策的目标是？好的软件设计的目标是？目标不外乎（is nothing less than）我乌托邦的描述
    
    软件架构的目标就用最小的人力资源去构建和维护所需要的系统

好的设计的评判不过是满足客户的需要（meet the needs）所需的工作量的评判。如果工作量很低，并且在整个系统的生命周期内都保持很低，则是好的设计。如果每个新的发布版本工作量都会增长，则是差的设计。就是这么简单。

## 案例分析 （case study）

举个例子：考虑下面的案例，它包含了来自一家希望匿名的公司的真实数据。

首先，让我们看工程师的增长，我很确信你会赞同这个趋势是鼓舞人心的。下图的增长肯定是重大成功的表示。

现在让我们看相同时期公司的生产率。简单的用代码行数去表示。

很明显这里有一些事情不对。尽管每个发布版本都有持续增长的开发来作支持，但是代码的增长看起来逼近了渐近线。

这里有一张更恐怖的图表，1.3展示了随着时间的变化，每行代码的成本。

这个趋势养不起，不管多赚钱的公司都会遇到这个时刻：这些曲线将会灾难性的消耗从商业模式中获得的利益，把公司逼入绝境，如果不彻底崩溃的话。

是什么造成了生产率的异常变化？为什么发布版本8相比发布版本1，生产代码要昂贵40倍？

## 混乱的标志

你正在看的是混乱的标志。当系统被匆忙的拼凑在一起,当程序员的绝对数量是输出的唯一驱动时，当在代码整洁度或结构设计上只有一点或没有想法时，你就会沿着这条曲线到达它危险的结局

1.4展示着这条曲线对于开发者看起来像什么。开始的时候接近100%的生产率，但是每个发布版本生产率都在下降，在第四个发布版本，很明显生产率已经逼近0了。

从开发者的角度看，这让人很失望，因为每个人工作都很辛苦，没有人会减少他们的努力。

尽管他们很努力的加班、奉献，他们不能再简单的去做很多事。他们的努力都从特性转化为了管理混乱，他们的工作也变成了把混乱从一个地方移到一个又一个地方，以至于只能开发很少的特性。

## 管理层的观点

如果你感觉很糟糕，想象一下这张图对管理层来说像什么，考虑图1.5，展示了同样周期内开发者每月的花费。

版本1交付的时候，每月花费只有几十万，版本二花费稍多。到了版本8每月要花费2kw，并且还在上升。

这张图很恐怖。很明显，一些令人震惊的事情发生了。一个期望是收入超过成本，好解释费用的合理。但是不管怎么看这幅图，它都值得关注

但是现在比较一下图1.5和1.2，初始每月花费几十万就可以有一堆功能。到最后每月2kw却几乎什么功能都没有。任何cfo看到这两张图都会知道要立即采取行动避免灾难。

但能采取什么行动呢？到底哪里出了问题？是什么造成了生产率的惊人下降？管理层除了跺脚和迁怒于开发，还能做什么？

## 哪里出了问题？

将近2600年前，伊索讲了一个龟兔赛跑的故事，故事的寓意有很多种

* 慢和稳能赢得比赛
* 比赛不是比速度快，又不是和强者战斗
* 欲速则不达

故事本身阐述了自负的愚蠢。兔子很自信于他的速度，不把比赛放在眼里，所以当乌龟越过终点线时还在打盹。

现代开发者在一个相似的比赛里，并且展示了相似的自负。不过他们不睡觉。许多现代开发者努力工作，不过他们脑子的一部分却在睡觉,知道什么是号，整洁，良构代码的那部分。（does matter）

开发者都会说同一个谎言：我们可以晚点把它搞干净；我们要首先上线。当然，事情不会被晚点清理，因为市场的压力不会减弱。简单的上市意味着在你身后有大批的竞争者，你必须尽力保持在前面。

因此开发不会切换模式，他们不会回头清理因为他们要去开发一个又一个的新特性。所以混乱就这样产生了，并且生产率持续接近于0.

就像兔子自负于它的速度，同样的，开发者也自负于他们维持生产力的能力。但是使他们工作效率降低的代码混乱程度在不断的爬行，不会睡觉也不会减弱。如果顺其自然，大约几个月左右工作效率就行降为0.

开发者说的更大的谎言是认为写混乱的代码让他们在前期走的很快，在后期慢下来。接受这个谎言的开发者展示了和和兔子一样的自负：他们有能力在将来从制造混乱切换到清理混乱的状态。但他们在事实方面犯了一个小错误。那个事实是“制造混乱总是比保持整洁慢”，无论你使用哪种时间尺度。

考虑下面由jason Gorman进行的特别的实验结果。Jason用6天时间进行了这个实验，每天他都完成一个简单的把整数转换为罗马数字的项目，当他预定义的验收测试用例集合通过是，他的工作就完成了。这项任务每天会花费少于30min。Jason在1,3,5使用一个有名的TDD开发方法，在其他3天，他没有用这个原则来写代码。

首先，注意图1.6显而易见的学习曲线。后面完成的比前面要快，同时也要注意使用TDD放吧比不使用快了将近10%。甚至最慢的TDD耗时都比最快的非TDD要快。

一些人认为这可能只是一个特例，但是对那些没有被兔子的自负所蒙蔽的人来说，这个结果在预料之中，因为他们知道软件开发中一个简单的道理
    
    做得快的唯一方法，就是做得好
    
这也是管理层的困境的答案。逆转工作效率下降和成本上升的唯一方法是停止和兔子一样的自负思想并且对他们制造的混乱负责。

开发者可能认为答案就是从摧毁和重新设计整个系统开始，但这只是又一次兔子的言论。把他们带向混乱的自负又同样的告诉他们，如果可以重来一次，他们可以做的更好。事实是不幸的

    他们的自负将会把重新设计带向和原始项目相同的混乱。
    
## 结论

在每一个方面，对于开发组织最好的选择是认识和避免自己的自负，开始认真对待他们软件架构的质量。

为了认真对待软件架构，你需要知道什么是好的软件架构。为了构建一个在设计和架构上有最小努力和最大生产效率的系统，你需要知道系统架构的哪些属性会导致这一目标。

这些就是本书要讲的内容。它描述了好的整洁的架构应该是什么样。便于软件开发者能够构建长期盈利的系统。
